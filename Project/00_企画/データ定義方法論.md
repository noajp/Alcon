データ構造はコードに大きな影響を与えるので、かなり重要視します。
 ただ、データ構造より先に考えるべきなのは「ドメイン」であり、このドメイン構造によって、正しいデータ構造の設計が可能になります。

実務でコードを書いていると、
「この処理、どこから手をつければいいんだろう」
と立ち止まる瞬間に何度も出会います。
少し仕様が変わっただけで影響範囲が読めなくなる。
1つ修正すると、思わぬ別の場所が壊れる。
自分では丁寧に書いているつもりなのに、どんどん扱いづらくなっていく。
こうした"壊れやすいコード"には、共通点があります。
それは、
データ構造が曖昧なまま実装に入っていること。
優秀なエンジニアほど、コードを書く前に
「まず扱うデータをどう設計するか」
に時間を使います。
これはセンスではなく、壊れにくいシステムを作るうえでの
再現性のあるプロセスです。
なぜデータから考えると壊れにくくなるのか

コードが壊れる原因は「処理が複雑だから」ではありません。
多くの場合、
扱うデータが曖昧なまま実装が進んでしまっている
ことが本質的な原因です。
処理から考え始めると、次のような問題が起きやすくなります。
想定外の値が混ざる
null / undefined が途中で暴れる
状態管理が if 文で散らばる
これは本来、コードを書く前に決めておくべき
「前提条件」がコードの外に残ったままになっている
状態です。
この"前提の漏れ"が、仕様変更のたびに壊れる構造を生みます。
一方でデータを先に設計しておくと、
何が入力なのか
何が正常な状態なのか
何が起きると不整合になるのか
が明確になり、実装に一貫した「軸」が生まれます。
何をデータ構造として扱うべきか

「データから考えろ」と言われても、
実務では"何をデータとみなすのか"が分からず迷いがちです。
ここからは、データ構造として扱うべきポイントを
4つの視点で整理します。
"情報"ではなく"状態"をデータとみなす

多くの人は「データ＝文字や数値」と捉えますが、
実務で重要なのは状態です。
たとえば：
ログイン前 / ログイン後
未読 / 既読
有効 / 無効
下書き / 公開
これらは UI のラベルではなく、
アプリケーションが保証すべき前提そのもの。
状態が曖昧なまま実装すると、
if 文が散らばり、仕様変更のたびに壊れます。
"値"だけでなく"関係"もデータ構造に含める

データ設計で見落とされがちなのは関係性です。
ユーザーと組織
記事とコメント
予約枠と担当者
商品と在庫
関係性が曖昧なまま実装すると、
「このデータ、どれと紐づいてるんだっけ？」
という混乱が必ず発生します。
関係は「おまけ」ではありません。
データ構造そのものの中心です。
"仕様に書かれていない前提"をデータ化する

実務には、仕様書では見落とされている重要な前提が必ず存在します。
例えば、
ユーザーは1つの組織にしか所属できない
予約は「担当者 × サービス × 日時」で一意になる
メッセージの編集履歴は削除後も保持する
こうした暗黙にされているかもしれない前提をデータに落とし込まないと、
機能がその前提に依存していたときに壊れるという事故が起きます。
優秀なエンジニアほど、
仕様に書かれていない前提を発掘してデータとして扱う
という工程を怠りません。
最初は「自然言語で書ける」ことが大事

最初からER図やクラス図を書く必要はありません。
まずやるべきなのは、
扱う状態や前提を自然言語で説明できるようにすること。
たとえば、
ユーザーは複数組織に所属できるが、デフォルト組織は1つ
予約は日時・担当者・サービスの3つが揃って成立する
メッセージ編集は可能だが、履歴は別レコードで保持する
自然言語で曖昧なら、コードではもっと曖昧になります。
実務でデータ構造を決めるときのステップ

ここからは、「実際どうやってデータ構造を決めればいいのか？」
という実務のプロセスを紹介します。
Step1：自然言語で「状態」「関係」「前提」を列挙する

まずはコードから離れて、
自然言語で現在の仕様を洗い出すところから始めます。
予約は日時 × 担当者 × サービスで構成される
ユーザーは複数組織に所属できるがデフォルト組織は1つ
メッセージ編集は可能だが履歴は残す
曖昧な表現でも構いません。
最初は「全体像を漏れなく書き出す」ことが大事です。
Step2：同じ概念をまとめ、不要な状態を削る

洗い出した状態や関係を見直し、
本当にアプリが管理すべき状態はどれか
UIの名前ではなく構造として必要な状態はどれか
を判断して整理します。
状態は多ければ多いほど壊れやすくなるため、
削る工程こそ設計の核心です。
Step3：変化する状態と変化しない状態を分ける

「どの値が変化し、どの値が不変か」を明確にします。
例：
予約の「作成日時」は不変
予約の「ステータス」は可変
ユーザーIDは不変
メールアドレスは可変
この境界線を引くだけで、更新ロジックのバグが激減します。
Step4：状態遷移（ステートマシン）を書く

状態が整理できたら、
どの状態からどの状態に遷移できるか を明文化します。
例（予約）：
draft → reserved → completed
draft → canceled
reserved → canceled
これにより、
到達しない状態
不正遷移
不整合の原因
がすぐに可視化されます。
Step5：データ構造として定義する（型・スキーマ化）

ここまで整理した情報を
型・スキーマ・ER図 に落とし込みます。
TypeScriptの型
Prisma schema
Rustのstruct + enum
Swiftのstruct/enum
DBのテーブル定義
状態・前提・関係が整理されているので、
ここから先の実装は驚くほどスムーズです。
まとめ：データ構造を決める作業は、実装より重要

データ構造の設計は、実装の"前作業"ではありません。
実装を壊れにくくするための中心工程 です。
曖昧なまま書き始めるほど壊れやすくなる
データが明確なら処理は自然とシンプルになる
状態・関係・前提が揃えば、仕様変更に強くなる
優秀なエンジニアがデータ構造を先に決めるのは、
センスではありません。
後の開発すべてを安定させる"最もコスパの良い投資"だからです。