# Alcon 統合企画書

> AI駆動型組織ワークマネジメントプラットフォーム

Alconは、人間とAIエージェントを包括的に管理し、組織の仕事を円滑に進めるためのプラットフォームです。

**重要な視点**: このツールは「開発者が組織を作る」のではなく、「ユーザーが自分の組織構造を自由に構築し、プロジェクトを管理する」ためのものです。設計時は常に俯瞰して抽象化し、特定のユースケースに縛られない柔軟性を持たせること。

---

# Part 1: ビジョンと哲学

## 1.1 ハンナ・アーレントの「人間の条件」から

アーレントは人間の活動を3つに分類した：

| 概念 | 原語 | 内容 | Alconでの対応 |
|------|------|------|---------------|
| **活動 (Action)** | Action | 他者と共に公共空間で何かを始める。政治的・人間的営み | `Action`（協働の場） |
| **仕事 (Work)** | Work | 耐久的な人工物を作る。世界に「モノ」を残す創造的営み | `Object`（構造設計） |
| **労働 (Labor)** | Labor | 生命維持のための反復的活動。消費されて何も残らない | `Elements`（実行単位） |

**そして、3つを結ぶもの:**

| 概念 | 役割 | Alconでの対応 |
|------|------|---------------|
| **判断 (Decision)** | 活動・仕事・労働を繋ぎ、意味を与える | `Decision`（ジョイント） |

## 1.2 現代ホワイトカラーの問題

現代のホワイトカラーワークの多くは、**「仕事に見える労働」** である。

```
労働（本来は標準化可能）
  ↓
道具がバラバラ（Slack, Excel, Notion, 独自システム...）
  ↓
解釈の余地が発生（誰がどう積み上げるかが属人化）
  ↓
労働なのに「仕事」的コストが発生
  ↓
生産性の低下
```

**問題の本質**: 生産性が低い道具を使っているから、労働にも「仕事的余地」（解釈の余地があり、積み上げる個人によって積み上げ方が違う状態）が発生している。

## 1.3 Alconの解決策

**労働の最小単位を統一する。**

どの会社でも、どの業界でも、積み上げるべき「1つの単位」は同じ形をしている。

この一貫性により：
- 労働から「解釈の余地」を排除
- 誰がやっても同じ積み上げ方になる
- 労働は労働として効率化される
- **人間は本当の「仕事」と「活動」に集中できる**

## 1.4 ビジョン

> 「労働を標準化し、人間を創造と活動に解放する」

Alconは単なるタスク管理ツールではない。
ホワイトカラーの「仕事に見える労働」を標準化し、人間とAIが協働する未来を実現するプラットフォーム。

**そしてその先には：**

> 「標準化された労働を機械に委譲し、人間は判断と創造に専念する」

## 1.5 コンセプト

**「AIが頭脳として働く、バージョン管理可能なワークマネジメントプラットフォーム」**

**AIは「アシスタント」ではなく「オペレーター」である。**
- AIがタスクを分析し、提案し、実行する
- 人間は最終的な意思決定と承認を行う
- UIはAIの思考プロセスと提案を可視化する

---

# Part 2: Core Concepts（新アーキテクチャ）

## 2.1 3層構造 + Decision

```
活動                    仕事                    労働
Action ←─ Decision ─→ Object ←─ Decision ─→ Elements
（協働・創造の場）      （構造設計）            （実行単位）

```

**Decision**は「層」ではなく「接続」。
各層を結び、「なぜこう繋がっているか」の根拠を与える。

## 2.2 各コンポーネントの役割

| コンポーネント    | アーレントの概念      | 役割  | 特徴 |
|-----------------|--------------------|------|------|
| **Document**    | 活動 | 協働・創造の場 | Miro的キャンバス、他者との協調 |
| **Object**      | 仕事 | 構造・設計単位 | 入れ子可能、何を切り出すかを決める |
| **Elements**    | 労働 | 実行単位      | 標準化、誰がやっても同じ結果 |
| **Subelements** | 労働 | 実行単位      | より細分化された実行単位 |

| **Decision** | (ジョイント) | 判断の記録 | 依存関係、責任根拠を付与 |

## 2.3 データ構造

```
Action（活動の場）
├── linked_to: Object / Elements
└── type: Canvas / Chat / Design

Object（入れ子可能な仕事単位）
├── parent_object_id  -- 階層化
├── Object（子）
│   └── Elements
│       └── Subelements
└── Elements
    └── Subelements

Decision（すべてを結ぶジョイント）
├── source_type / source_id
├── target_type / target_id
├── relation: 'creates' | 'decomposes' | 'prioritizes' | ...
├── rationale: なぜ
└── decided_by: 誰が
```

新構造のメリット：
- **Object**は単純に入れ子（parent_object_id）で自由に階層化
- **Document**という明確な「活動の場」を配置
- **Decision**でコンポーネント間の「判断」を明示的に記録

## 2.4 Decision（判断）の設計

**Decisionは「ノード」ではなく「エッジ（ジョイント）」として設計する。**

```
Decision = ジョイント（接続）
├── source_type: 'document' | 'object' | 'element'
├── source_id: UUID
├── target_type: 'object' | 'element'
├── target_id: UUID
├── relation: 'creates' | 'decomposes' | 'prioritizes' | 'assigns' | 'terminates'
├── rationale: 判断理由（なぜこう繋いだか）
├── alternatives: 他にどんな選択肢があったか
├── trade_off: 何を諦めたか
├── decided_by: Worker（誰が判断したか）
└── decided_at: タイムスタンプ
```

**Decisionの例**:
- Document「設計会議」 → Decision「このObjectを作ると決定」 → Object「新機能開発」
- Object「新機能開発」 → Decision「こう分解すると決定」 → Elements「API設計」「UI実装」
- Elements「API設計」 → Decision「この人に任せると決定」 → Worker「山田」

**Decisionの価値**:
- 「なぜこの判断をしたか」が常に追跡可能
- 承認フロー・履歴はDecisionを可視化したものに過ぎない
- AIが過去の判断パターンを学習できる
- 組織の意思決定プロセスが可視化される
- **将来、物理AIに労働を委譲する際の責任追跡**

## 2.5 Document（活動の場）の機能

| 機能 | 説明 | ユースケース |
|------|------|-------------|
| **Canvas** | Miro風キャンバス | ブレインストーミング、構造設計 |
| **Chat** | リアルタイムチャット | 議論、質問、情報共有 |
| **Design** | デザインツール | ワイヤーフレーム、モックアップ |
| **Editor** | リッチテキスト | 仕様書、議事録、手順書 |

Documentは「判断を生み出す場」であり、その結果がDecisionを通じてObject/Elementsに反映される。

## 2.6 具体例

### IT企業の例
```
Document: 「プロダクト設計キャンバス」（Canvas）
    │
    │ Decision: 「Q1でMVPリリースを決定」（理由: 競合の動向）
    ↓
Object: 「ECサイトリニューアル」
├── Object: 「フロントエンド」
│   │
│   │ Decision: 「React採用」（理由: チームスキル、trade-off: Vue経験者の学習コスト）
│   │
│   ├── Element: 「商品一覧ページ実装」
│   │   ├── Subelement: 「API連携」
│   │   └── Subelement: 「UIコンポーネント作成」
│   └── Element: 「決済フロー実装」
└── Object: 「バックエンド」
    ├── Element: 「商品API開発」
    └── Element: 「認証システム構築」

Document: 「技術仕様書」（Editor）← Object「ECサイトリニューアル」に紐づけ
```

### 病院の例
```
Document: 「朝カンファレンス」（Chat）
    │
    │ Decision: 「新規患者3名を内科病棟に受け入れ」
    ↓
Object: 「内科病棟」
├── Object: 「3階東」
│   ├── Element: 「山田太郎」（患者）
│   │   ├── Subelement: 「血液検査」
│   │   └── Subelement: 「CT検査」
│   └── Element: 「佐藤花子」
└── Object: 「3階西」
    └── Element: 「鈴木一郎」

Document: 「治療計画書」（Editor）← Element「山田太郎」に紐づけ
```

## 2.7 なぜ「Task」ではなく「Elements」か？

業界によって扱う単位が異なる：
- IT企業 → タスク
- 病院 → 患者
- 営業 → 案件・商談
- カスタマーサポート → チケット

抽象的な「Elements」なら、どの業界でも違和感なく使える。

## 2.8 Workers（ワーカー）

Elementsを実行する主体。人間とAIを同列に扱う：

```
Worker
├── Human Worker（人間）
├── AI Agent Worker（自律的に動くAI）
└── Robot Worker（物理的なロボット）← 将来
```

両者に共通する属性：
- 名前、役割、スキル
- 担当Elements、稼働状況
- パフォーマンスメトリクス

**AIが労働を担い、人間が「仕事」と「活動」に集中する。**

---

# Part 3: データベーススキーマ

## 3.1 テーブル構成

| 概念 | DBテーブル | 備考 |
|------|-----------|------|
| Object | `objects` | parent_object_idで入れ子 |
| Element | `elements` | object_idでObjectに紐づく |
| Subelement | `subelements` | element_idでElementに紐づく |
| Document | `documents` | linked_type, linked_idで紐づけ |
| Decision | `decisions` | ジョイント型（source → target） |
| Worker | `workers` | human / ai_agent / robot |
| Element Assignee | `element_assignees` | ElementとWorkerの関連 |

## 3.2 スキーマ詳細

```sql
-- Object（仕事：入れ子可能）
objects (
  id UUID PRIMARY KEY,
  parent_object_id UUID REFERENCES objects(id) ON DELETE SET NULL,
  name TEXT NOT NULL,
  description TEXT,
  color TEXT,
  icon TEXT,
  order_index INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
)

-- Elements（労働：実行単位）
elements (
  id UUID PRIMARY KEY,
  object_id UUID REFERENCES objects(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  section TEXT,
  status TEXT DEFAULT 'todo',
  priority TEXT DEFAULT 'medium',
  due_date DATE,
  estimated_hours DECIMAL(5,2),
  actual_hours DECIMAL(5,2),
  order_index INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
)

-- Subelements（構成要素）
subelements (
  id UUID PRIMARY KEY,
  element_id UUID REFERENCES elements(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  is_completed BOOLEAN DEFAULT FALSE,
  order_index INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
)

-- Documents（活動の場）
documents (
  id UUID PRIMARY KEY,
  name TEXT NOT NULL,
  document_type TEXT NOT NULL,  -- 'canvas' | 'chat' | 'design' | 'editor'
  content JSONB,
  -- 紐づけ（任意）
  linked_type TEXT,  -- 'object' | 'element' | NULL
  linked_id UUID,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
)

-- Decisions（ジョイント）
decisions (
  id UUID PRIMARY KEY,
  -- 接続元
  source_type TEXT NOT NULL,  -- 'document' | 'object' | 'element'
  source_id UUID NOT NULL,
  -- 接続先
  target_type TEXT NOT NULL,  -- 'object' | 'element' | 'worker'
  target_id UUID NOT NULL,
  -- 判断の内容
  relation TEXT NOT NULL,  -- 'creates' | 'decomposes' | 'prioritizes' | 'assigns' | 'terminates'
  rationale TEXT,
  alternatives JSONB,  -- [{option, predicted_outcome}]
  trade_off TEXT,
  -- 誰が・いつ
  decided_by UUID REFERENCES workers(id),
  decided_at TIMESTAMP DEFAULT NOW(),
  -- メタデータ
  is_explicit BOOLEAN DEFAULT TRUE,  -- 明示的に記録されたか
  confidence TEXT DEFAULT 'certain',  -- 'certain' | 'tentative' | 'forced'
  created_at TIMESTAMP DEFAULT NOW()
)

-- Workers（ワーカー）
workers (
  id UUID PRIMARY KEY,
  type TEXT NOT NULL,  -- 'human' | 'ai_agent' | 'robot'
  name TEXT NOT NULL,
  role TEXT,
  email TEXT,
  avatar_url TEXT,
  ai_model TEXT,
  ai_config JSONB,
  -- 将来: 物理AI用
  device_id TEXT,
  capabilities JSONB,  -- ['navigate', 'manipulate', 'scan', ...]
  status TEXT DEFAULT 'active',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
)

-- Element Assignees（担当者）
element_assignees (
  id UUID PRIMARY KEY,
  element_id UUID REFERENCES elements(id) ON DELETE CASCADE,
  worker_id UUID REFERENCES workers(id) ON DELETE CASCADE,
  role TEXT DEFAULT 'assignee',
  assigned_at TIMESTAMP DEFAULT NOW()
)

-- Custom Columns（カスタムカラム）
custom_columns (
  id UUID PRIMARY KEY,
  object_id UUID REFERENCES objects(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  column_type TEXT NOT NULL,
  options JSONB,
  order_index INTEGER DEFAULT 0,
  is_visible BOOLEAN DEFAULT TRUE,
  width INTEGER,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
)

-- Custom Column Values（カスタムカラム値）
custom_column_values (
  id UUID PRIMARY KEY,
  column_id UUID REFERENCES custom_columns(id) ON DELETE CASCADE,
  element_id UUID REFERENCES elements(id) ON DELETE CASCADE,
  value JSONB,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
)
```

## 3.3 Supabase Project

- **Project ID**: rkugtcqztkkacvoylupw
- **Region**: ap-northeast-2

---

# Part 4: UI/UXデザイン仕様

## 4.1 デザイン原則

- **テーマ**: Supabase Dashboard inspired dark theme
- **カラー**: モノクロベース（#171717, #1c1c1c）、白/グレーのアクセントのみ
- **レイアウト**: VSCode-like（ActivityBar + Sidebar + MainContent）
- **ロゴ**: シンプルに「Alcon」テキスト表示
- **ナビゲーション**: 全階層リスト表示

## 4.2 カラートークン

### Background Colors
| Token | Hex | Usage |
|-------|-----|-------|
| bg-primary | `#1E1E1E` | Main background |
| bg-secondary | `#252526` | Sidebar, panels |
| bg-tertiary | `#2D2D30` | Tabs bar, inputs |
| bg-hover | `#2A2D2E` | Hover state |
| bg-active | `#37373D` | Active/selected |

### Text Colors
| Token | Hex | Usage |
|-------|-----|-------|
| text-primary | `#CCCCCC` | Main text |
| text-secondary | `#858585` | Secondary text |
| text-muted | `#6E6E6E` | Disabled/muted |

### Status Colors
| Token | Hex | Usage |
|-------|-----|-------|
| status-success | `#4EC9B0` | Success/completed |
| status-warning | `#DCDCAA` | Warning |
| status-error | `#F14C4C` | Error/blocked |
| status-info | `#75BEFF` | Info |

## 4.3 レイアウト構造

```
┌─────────────────────────────────────────────────────────────────────────┐
│ TITLE BAR (40px)                                                        │
│ [Logo] [                Search (Cmd+K)                ] [Bell] [AI] [User]│
├────┬───────────┬─────────────────────────────────────┬──────────────────┤
│ A  │ SIDEBAR   │ MAIN CONTENT                        │ AI PANEL         │
│ C  │ (260px)   │ (flex: 1)                           │ (350px)          │
│ T  │           │                                     │                  │
│ I  │ Documents │ ┌─────────────────────────────────┐ │ Context          │
│ V  │ ────────  │ │ TABS BAR (35px)                 │ │ ────────         │
│ I  │ Objects   │ │ [Tab 1] [Tab 2] [+]             │ │ @element: xxx    │
│ T  │ TreeView  │ ├─────────────────────────────────┤ │                  │
│ Y  │           │ │                                 │ │ Chat             │
│    │           │ │ CONTENT AREA                    │ │ ────────         │
│ B  │           │ │                                 │ │ Messages...      │
│ A  │           │ │ Table View / Canvas / Chat      │ │                  │
│ R  │           │ │                                 │ │ Quick Actions    │
│    │           │ │                                 │ │ ────────         │
│(48)│           │ │                                 │ │ [Analyze]        │
│ px │           │ └─────────────────────────────────┘ │                  │
├────┴───────────┴─────────────────────────────────────┴──────────────────┤
│ STATUS BAR (22px)                                                       │
│ [main] [Synced] [AI Active]                    [2 pending] [v12] [3]    │
└─────────────────────────────────────────────────────────────────────────┘
```

---

# Part 5: 技術スタック

## 5.1 現在の実装

- **Frontend**: Next.js 16 (App Router, Turbopack)
- **Backend**: Supabase (PostgreSQL, Auth, Edge Functions)
- **Deployment**: Vercel
- **AI**: Claude API via Supabase Edge Functions (Tool Use)

## 5.2 Supabaseの機能活用

```
┌─────────────────────────────────────────────────────────────┐
│                    Supabase                                 │
├─────────────────────────────────────────────────────────────┤
│  Auth          │ 認証・ユーザー管理                          │
│  Database      │ PostgreSQL + RLS（行レベルセキュリティ）      │
│  Storage       │ ファイル保存（S3互換）                       │
│  Realtime      │ WebSocketでDB変更をリアルタイム配信          │
│  Edge Functions│ サーバーレス関数（Deno/TypeScript）          │
│  RPC           │ PostgreSQL関数をAPI経由で呼び出し            │
│  PostgREST     │ DBスキーマから自動REST API生成               │
└─────────────────────────────────────────────────────────────┘
```

---

# Part 6: AI統合アーキテクチャ

## 6.1 AIは「機能」ではなく「基盤」

**Alconのアプローチ:**
```
User → AI Agent → Database
         ↑
        UI (AIの操作を可視化・承認する窓口)
```

## 6.2 AIエージェントの種類

| エージェント種別 | 役割 | トリガー |
|----------------|------|---------|
| Task Analyzer | タスク分析・分解・見積もり | タスク作成、大きなタスク検出 |
| Document Editor | ドキュメント生成・編集・要約 | ドキュメント操作 |
| Dependency Manager | 依存関係の検出・提案 | タスク間の関連性検出 |
| Scheduler | スケジュール最適化、リソース配分 | 期日変更、ワークロード超過 |
| Decision Recorder | Decisionの自動記録・提案 | Document内での議論検出 |
| Orchestrator | 複数エージェントの調整 | 複雑なリクエスト |

## 6.3 Edge Functions

### 実装済み
1. **validate-task**: Elements作成前の重複・競合チェック
2. **analyze-change**: Elements変更時の影響分析

### 計画中
- **decision-suggester**: Documentでの議論からDecision候補を自動提案
- **dependency-analyzer**: 部門間の隠れた依存関係を自動検出
- **workload-balancer**: ワーカーの負荷を最適化提案
- **auto-assigner**: Elementsを最適なワーカーに自動アサイン

---

# Part 7: 設計原則

## 7.1 判断基準

設計の判断に迷ったら：

1. **一般化**: 特定のケースではなく、一般化できるか？
2. **AI同列**: 人間とAIを同列に扱えているか？
3. **自由度**: ユーザーが自由に構造を作れるか？
4. **汎用性**: 業界を問わず使える用語か？
5. **標準化**: 労働を標準化し、解釈の余地を排除できているか？
6. **判断の可視化**: Decisionとして記録・追跡できているか？
7. **将来の拡張**: 物理AIへの委譲を閉じていないか？

## 7.2 アーレントの3概念との対応

| 設計要素 | アーレントの概念 | 設計意図 |
|----------|------------------|----------|
| **Document** | 活動（Action） | 他者と共に創造し、判断を生み出す場 |
| **Object** | 仕事（Work） | 耐久的な構造を設計する |
| **Elements** | 労働（Labor） | 標準化され、消費される作業 |
| **Decision** | - | 3つを繋ぐジョイント。判断と責任の記録 |

## 7.3 Decisionの4つの作法

哲学的探究から導かれた、判断に対する責任の作法：

| 作法 | 意味 | Alconでの実装 |
|------|------|---------------|
| **判断を避けないこと** | 不完全な情報でも決断する | AIが判断ポイントを検出し、先送りを防ぐ |
| **判断を絶対視しないこと** | 常に修正可能性を残す | revision_deadline、confidence属性 |
| **判断の理由を語れること** | 他者との対話可能性を保つ | rationale、alternatives、trade_off |
| **判断の代償を引き受けること** | 何を失ったかを自覚する | trade_off、帰結追跡（将来実装） |

---

# Part 8: ロードマップ

## Phase 1: 基盤 (完了)
- [x] 組織階層表示（Sidebar）
- [x] Elements管理（Table view）
- [x] ドラッグ&ドロップでの組織再編
- [x] カスタムカラム

## Phase 2: アーキテクチャ移行 (現在)
- [ ] Systemテーブル廃止、Objectの入れ子化
- [ ] Decisionsテーブル追加（ジョイント型）
- [ ] Documentsテーブル追加
- [ ] UI更新（Document表示、Decision記録）

## Phase 3: AI協働
- [ ] AIエージェントの設定・管理UI
- [ ] Decision自動提案（Document内の議論から）
- [ ] 依存関係の自動検出
- [ ] Tool Use による推論

## Phase 4: 拡張
- [ ] リアルタイム通知
- [ ] タイムライン/ガントチャート
- [ ] 権限管理（RBAC）
- [ ] バージョン管理（Git-like）
- [ ] カレンダー連携

---

# Part 9: 将来ビジョン（妄想）

> 以下は技術的・社会的条件が整った将来の構想であり、現在の開発スコープには含まれない。
> ただし、**現在の設計がこれらの可能性を閉じないこと**を意識する。

## 9.1 労働の機械への委譲

アーレントの「労働」の定義：
- **誰がやっても同じ結果**
- **標準化可能**
- **消費されて何も残らない**

これは**人間がやる必要がない**。

Alconが「労働を標準化する」なら、その先には**「標準化された労働を機械に委譲する」**がある。

```
┌─────────────────────────────────────────────┐
│  Human Layer（活動・仕事・判断）            │
│  Document + Object + Decision               │
│  「何を」「なぜ」「誰が責任を持つか」       │
└─────────────────────────────────────────────┘
                    │
                    │ API / Protocol
                    ▼
┌─────────────────────────────────────────────┐
│  Execution Layer（労働）                    │
│  Elements → Physical AI                     │
│  「どうやって」は機械が自律的に判断         │
└─────────────────────────────────────────────┘
```

## 9.2 The Division的インターフェース

ゲーム「The Division」のISAC（腕時計型デバイス）のような、現場と企画を繋ぐインターフェース。

```
デスク（企画・設計）
┌─────────────────────────────┐
│  PC / タブレット            │
│  Document, Object, Decision │
│  「何を」「なぜ」を設計     │
└─────────────────────────────┘
            │
            │ 同期
            ▼
現場（実行・監督）
┌─────────────────────────────┐
│  時計型デバイス             │
│  Elements, 物理AIステータス │
│  「今やること」を確認       │
│  「例外判断」を下す         │
└─────────────────────────────┘
            │
            │ 指令
            ▼
物理AI（労働の実行）
┌─────────────────────────────┐
│  ドローン / ロボット        │
│  Elementsを自律実行         │
│  想定外は人間に問い合わせ   │
└─────────────────────────────┘
```

### 時計型UIのイメージ

```
┌──────────────────────┐
│  ◉ ALCON   14:32    │
├──────────────────────┤
│  現在のElements      │
│  ┌────────────────┐  │
│  │📦 部品X回収    │  │
│  │   倉庫A → B    │  │
│  │   残り: 8/10   │  │
│  └────────────────┘  │
├──────────────────────┤
│  物理AI: 3台稼働     │
│  ●● ●○ ○○         │
├──────────────────────┤
│  ⚠ 判断待ち: 1件    │
│  「経路Bが混雑」     │
│  [A継続] [C迂回]     │
└──────────────────────┘
```

### 物理AIとの対話

```
Seeker Mine的AI：
「障害物があります。迂回しますか？待機しますか？」
    │
    ▼
時計に通知
    │
    ▼
人間がタップで選択 → Decision記録
    │
    ▼
AIが再開
```

人間は**例外処理と判断**だけをする。

## 9.3 AR統合

時計型デバイスで画面を投影し、特殊なコンタクトレンズで可視化する。

```
現場で見える景色
┌─────────────────────────────────────┐
│                                     │
│      [倉庫A]                        │
│         ↓ ルート表示                │
│    ●───────────→                   │
│    Seeker#1                         │
│    「部品X回収中 3/10」             │
│                                     │
│              ⚠ Seeker#2             │
│              「経路判断待ち」        │
│              [タップで選択]         │
│                                     │
└─────────────────────────────────────┘
```

The Divisionのエージェントビュー、そのまま。

## 9.4 なぜDecisionが重要になるか

物理AIに労働を委譲するとき、**「なぜこの指令を出したか」**の記録が必要になる。

```
もし事故が起きたら：
「なぜこのロボットはここにいたのか」
    ↓
Decision：「この経路を選んだのは誰の判断か」
    ↓
Object：「このプロジェクトの構造設計は誰が責任を持つか」
    ↓
Document：「なぜこのプロジェクトを始めたか」
```

**Decisionが「責任の追跡可能性」を担保する。**

## 9.5 技術的前提条件

これらの実現には以下の技術的・社会的条件が必要：

| 条件 | 現状 | 必要なもの |
|------|------|------------|
| 時計型投影デバイス | 未実現 | ホログラム技術、小型プロジェクタ |
| 可視化コンタクト | 研究段階 | ARコンタクトレンズの実用化 |
| 自律移動ロボット | 部分的に実現 | 汎用的な屋内外ナビゲーション |
| 法的責任フレームワーク | 未整備 | ロボット事故時の責任分担ルール |

**現在のAlconは、これらが実現したときに「判断と責任」の基盤として機能できるよう設計する。**

---

# Part 10: プロジェクト構造

## 10.1 ファイル構成

```
/src
  /app
    page.tsx          # メインエントリ
  /components
    /layout
      TitleBar.tsx    # 上部バー（ロゴ、検索）
      ActivityBar.tsx # 左端アイコンバー
      Sidebar.tsx     # 組織ツリー表示
      MainContent.tsx # メインコンテンツ領域
      AIPanel.tsx     # AIアシスタントパネル
    /elements
      ElementList.tsx # Elements一覧表示
    /documents
      Canvas.tsx      # Miro風キャンバス
      Chat.tsx        # チャット
      Editor.tsx      # リッチテキスト
    /decisions
      DecisionLog.tsx # 判断履歴表示
    /ui
      (shadcn/ui components)
  /hooks
    useSupabase.ts    # データ取得・操作
  /lib
    supabase.ts       # Supabaseクライアント
    utils.ts          # ユーティリティ
  /types
    database.ts       # 型定義
```

## 10.2 環境変数

```
NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=
```

## 10.3 開発コマンド

```bash
npm run dev      # 開発サーバー起動
npm run build    # 本番ビルド
npx vercel --prod # 本番デプロイ
```

---

# 付録A: 用語集

| 用語 | 定義 |
|------|------|
| **Document** | 協働・創造の場。Canvas, Chat, Editorなどの機能を持つ |
| **Object** | 仕事の構造単位。入れ子可能 |
| **Elements** | 最小作業単位。業界によりタスク、患者、案件など |
| **Subelements** | Elementsの構成要素。チェックリスト項目など |
| **Decision** | 判断の記録。Document/Object/Elements間を結ぶジョイント |
| **Worker** | 作業主体。Human, AI Agent, Robot |

---

# 付録B: 参考資料

- Hannah Arendt "The Human Condition" (1958)
- Asana Work Graph: https://asana.com/resources/work-graph
- Supabase Docs: https://supabase.com/docs
- Anthropic Claude API: https://docs.anthropic.com
- Tom Clancy's The Division (Ubisoft) - ISAC Interface Design

---

**文書バージョン:** 4.0
**最終更新:** 2026年1月
